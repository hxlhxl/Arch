ref: https://www.youtube.com/watch?v=8aGhZQkoFbQ
JavaScript采用异步事件驱动编程模型，简单点就是JavaScript通过浏览器提供的时间模型API和用户产生交互。


# 事件绑定

## DOM元素直接绑定
```
<div onclick="alert(2)"></div>
```

```
<div onclick="myalert(2)"></div>
<script>
    function myalert(str) {
        alert(str);
    }
</script>
```
## JS代码绑定

缺点： 在同一个ele上绑定相同事件会被覆盖，必须自定义绑定函数，判断之前有么有绑定，很麻烦
```
<div id="btn"></div>

ele = document.getElementById("btn");
ele.onClick = function() {
    // this指向DOM元素
    alert("hello world")
}

```

## JS事件监听【现代标准绑定】

ele.addEventListener(event,handler,useCapture);

- ele: DOM元素
- event: 事件类型
- handler: 事件回调
- useCapture: 是否使用捕获，一般为false

``` 兼容封装

function addEvent(target, type, handler) {
        if (target.addEventListener) {
            target.addEventListener(type, handler, false);
        } else {
            target.attachEvent('on' + type, function() {
                // ie中this指向了window，这里使用call修正
                return handler.call(target)
            });
        }
    }
```

## 例子

``` 答案3\4\5\1
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
<script src="https://code.jquery.com/jquery-3.0.0.js"></script>
  <title>JS Bin</title>
</head>
<body>
<a href="javascript:alert(1)" onclick="alert(2)" id="link">click me</a>
<script>
    var link = document.getElementById('link');
    link.onclick = function() { alert(3); }

    $('#link').bind('click', function() { alert(4); });
    $('#link').bind('click', function() { alert(5); });
</script>
</body>
</html>
```

# 默认事件
event.preventDefault()

# 事件冒泡

大部分事件会沿着事件触发的目标元素往上传播。比如：body>div>p>span 如果他们都注册了点击事件，那么在 span 元素上触发点击事件后 p,div,body 各自的点击事件也会按顺序触发。

``` 弹出p、 div 、 body
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
<script src="https://code.jquery.com/jquery-3.0.0.js"></script>
  <title>JS Bin</title>
</head>
<body>
<div id="div">
  <p id="p">点我</p>
</div>
<script>
    document.body.onclick = function(){
      alert('body');
    }
    document.getElementById("div").onclick = function() {
      alert('div');
    }
    document.getElementById("p").onclick = function() {
      alert('p');
    }
</script>
</body>
</html>
```

## 阻止事件冒泡

```
function stopPropagation(event) {
        event = event || window.event;
        if (event.stopPropagation) {
            event.stopPropagation()
        } else {// IE
            event.cancelBubble = true
        }
    }
```


# 事件对象 


标准浏览器中在事件处理程序被调用时 事件对象 会通过参数传递给处理程序，IE 8 及以下浏览器中事件对象可以通过全局的 window.event 来访问。比如我们要获取当前点击的 DOM Element


```
<script>
    addEvent(document, 'click', function(event) {
        // IE 8 以下 => undefined
        console.log(event);
    });
    // 兼容
    addEvent(document, 'click', function(event) {
        event = event || window.event;
        // 标准浏览器 => [object HTMLHtmlElement]
        // IE 8 以下 => undefined
        console.log(event.target);
        var target = event.target || event.srcElement;

        console.log(target.tagName);
    });
</script>

```


# 事件代理Event Delegation
Event Delegation的原理在于事件冒泡

```
<ul id="list"></ul>
<script>
function delegateEvent(el, eventType, fn) {
    addEvent(el, eventType, function(event) {
        event = event || window.event;
        var target = event.target || event.srcElement;
        fn(target);
    });
}

var el = document.getElementById('list');
// 用 setTimeout 模拟 Ajax 伪代码
setTimeout(function() {
    var ajaxData = '<li id="item-1">item1</li> <li id="item-2">item2</li> <li id="item-3">item3</li> <li id="item-4">item4</li> <li id="item-5">item5</li>';
    el.innerHTML(ajaxData)
}, 1000);

delegateEvent(el, 'click', function(target) {
    console.log(target.id);
});
</script>
```



# 任务队列 https://zhuanlan.zhihu.com/p/30290270

microtasks:

process.nextTick
promise
Object.observe
MutationObserver
macrotasks:

setTimeout
setInterval
setImmediate
I/O
UI渲染
据whatwg规范介绍：

一个事件循环(event loop)会有一个或多个任务队列(task queue)
每一个 event loop 都有一个 microtask queue
task queue == macrotask queue != microtask queue
一个任务 task 可以放入 macrotask queue 也可以放入 microtask queue 中
调用栈清空(只剩全局)，然后执行所有的microtask。当所有可执行的microtask执行完毕之后。循环再次从macrotask开始，找到其中一个任务队列执行完毕，然后再执行所有的microtask，这样一直循环下去

